<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个小工具的开发日记]]></title>
    <url>%2Fblog%2F2019%2F08%2F28%2F%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 7月4日新开这本日记，也为了督促自己下个学期多下些苦功。先要读完手边的莎士比亚的《亨利八世》。7月13日打牌。7月14日打牌。7月15日打牌。7月16日胡适之啊胡适之！你怎么能如此堕落！先前订下的学习计划你都忘了吗？子曰：“吾日三省吾身。”不能再这样下去了！7月17日打牌。7月18日打牌。 以上摘自胡适先生的留学日记，明明是别人的故事，主人公却好像是自己。 于是抽空就有了此文，虽然还是咸鱼，但至少死鱼眼里泛出些许光彩了。 正文闲话不提，直接进入正文。故事的起因就是最近常跑人资办公室的我被人事姐姐们拜托帮忙做一个小工具，希望能够在培训会上用来随机抽问题然后找人回答，然后希望这个小工具能够尽快做好给她们。 我寻思这不挺简单么，也就顺口答应了下来。事后证明…… 真的很简单，不然本咸鱼为什么用这个故事来水文呢！？ 事情虽然简单，该走的流程还是要走的，我们按照软件开发流程一步步来。 需求分析一番沟通，确认了人事姐姐们的主要需求如下： 随机抽号：可以设置抽取数字范围和抽取数字个数，点开始按钮数字开始滚动，点结束按钮出现抽号结果 背景与标题设置：可以设置抽号程序的背景界面与大标题，让抽号程序显示内容和会议更加贴合 设计考虑开发速度和复杂度，这个小工具简单地用python开发就完事了，毕竟人生苦短，我用python。 技术选型 开发语言：python 程序架构：cs架构（一个自带GUI的小工具而已，没必要搞bs架构） 主要python工具包：tkinter(标准库)，Pillow(图像处理库) 界面设计灵魂画师上线！ 开发又到了我们最爱的coding环节，请各位打开浏览器，面向搜索引擎（最好是Google）开始编写代码。 具体的我们就不讲了，源码都在这，tkinter不会用请看官方文档，就主要说一下一些有趣的细节。 如何设置一个弹出窗口用于接收参数设置：其实就是编写一个主窗口类（继承tk.TK类），一个弹出窗口类（继承tk.Toplevel类）。大致的流程是这样的： 创建主窗口实例； 触发绑定在主窗口实例上的触发式组件； 创建弹出窗口实例； 通过弹出窗口会话收集数据； 主窗口实例等待弹出窗口会话销毁； 主窗口实例获取弹出窗口实例收集到的数据。 sample:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import tkinter as tk# 主窗class MainWindow(tk.Tk): def __init__(self): super().__init__() self.title('主窗口') # 程序参数/数据 self.name = tk.StringVar() self.name.set('张三') self.age = tk.IntVar() self.age.set(30) # 设置主窗口界面 self.setupUI() def setupUI(self): row1 = tk.Frame(self) row1.pack(fill="x") tk.Label(row1, text='姓名：', width=8).pack(side=tk.LEFT) self.l1 = tk.Label(row1, textvariable=self.name, width=20) self.l1.pack(side=tk.LEFT) row2 = tk.Frame(self) row2.pack(fill="x") tk.Label(row2, text='年龄：', width=8).pack(side=tk.LEFT) self.l2 = tk.Label(row2, textvariable=self.age, width=20) self.l2.pack(side=tk.LEFT) row3 = tk.Frame(self) row3.pack(fill="x") tk.Button(row3, text="设置", command=self.setup_config).pack(side=tk.RIGHT) # 通过Button触发 # 设置参数 def setup_config(self): # 接收弹窗的数据 res = self.ask_userinfo() if res is None: return # 更改参数，更新界面 self.name.set(res[0]) self.age.set(res[1]) # 弹窗 def ask_userinfo(self): popup_window = PopupWindow() # 创建弹窗实例 self.wait_window(popup_window) # 等待弹窗会话关闭 return popup_window.userinfo # 获取绑定在弹窗实例私有变量上的数据# 弹窗class PopupWindow(tk.Toplevel): def __init__(self): super().__init__() self.title('弹出窗口') # 设置弹窗界面 self.setup_UI() def setup_UI(self): row1 = tk.Frame(self) row1.pack(fill="x") tk.Label(row1, text='姓名：', width=8).pack(side=tk.LEFT) self.name = tk.StringVar() tk.Entry(row1, textvariable=self.name, width=20).pack(side=tk.LEFT) row2 = tk.Frame(self) row2.pack(fill="x", ipadx=1, ipady=1) tk.Label(row2, text='年龄：', width=8).pack(side=tk.LEFT) self.age = tk.IntVar() tk.Entry(row2, textvariable=self.age, width=20).pack(side=tk.LEFT) row3 = tk.Frame(self) row3.pack(fill="x") tk.Button(row3, text="确定", command=self.save).pack(side=tk.LEFT) tk.Button(row3, text="取消", command=self.cancel).pack(side=tk.LEFT) def save(self): self.userinfo = [self.name.get(), self.age.get()] # 将用户输入的数据绑定到实例私有变量上 self.destroy() # 销毁窗口 def cancel(self): self.userinfo = None self.destroy()if __name__ == '__main__': app = MainWindow() app.mainloop() 如何设置程序背景图片tkinter在界面美化这方面其实并不是很好用，在设置程序图片这一块遇上了不少坑，权且记录一下： 无法直接对tk.TK或者tk.Frame这类容器设置背景图片，最多设置背景色（至少我没找到什么好办法），解决方法就是搞一个tk.Label平铺在整个tk.TK上，然后通过tk.Label的image属性设置背景图片； 在按照上述方法设置背景图片的过程中发现图片并未平铺到整个tk.Label,需要手动设置图片大小；且需要预先使用PIL对图片进行处理，否则某些图片格式tkinter不支持； sample:1234567891011import tkinter as tkfrom PIL import ImageTk,Imageroot=tk.Tk(bg='blue') # 设置一个背景色方便看出问题width,height=root.maxsize() # 获取屏幕大小root.geometry('&#123;&#125;x&#123;&#125;'.format(width,height)) # 最大化程序窗口image=Image.open('1.jpg')image=image.resize((width,height),Image.ANTIALIAS) # 不手动调整图片尺寸的话会发现图片不会平铺到整个tk.Label上bg_image=ImageTk.PhotoImage(image) # 利用PIL形成转换管道的方式才能正确读取jpg图片l=tk.Label(root,bg='white',image=bg_image) l.pack(expand=True,fill=tk.BOTH) # 确认label已经平铺到整个程序窗口 测试与发布 测试：xjbd一遍，OK了； 发布：利用pyinstaller将程序打包成exe即可。 总结我对自己说：“张杰啊张杰！你怎么能如此堕落！先前立的flag你都忘了吗？子曰：‘吾日三省吾身。’不能再这样下去了！”]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python and Selenium]]></title>
    <url>%2Fblog%2F2019%2F07%2F05%2FPython-and-Selenium%2F</url>
    <content type="text"><![CDATA[What’s Selenium Selenium automates browsers. That’s it! What you do with that power is entirely up to you. Primarily, it is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should!) be automated as well. Selenium has the support of some of the largest browser vendors who have taken (or are taking) steps to make Selenium a native part of their browser. It is also the core technology in countless other browser automation tools, APIs and frameworks. 以上摘自Selenium官方首页 一句话概括：Selenium可以自动控制浏览器，一般用于自动化测试，但是你想用它做其他的事情（比如爬虫、比如代替做一些无聊重复的基于网站的工作）当然也是OK的，总之根据你的需要自己鼓捣去吧。 Why Selenium目前接触过的同类自动化测试工具有3个： Selenium Puppeteer Splash 他们各有优缺点，根据需要使用，个人的话更偏向于使用Selenium: 工具 官方文档 社区活跃度 编程语言 支持浏览器 安装 API BUG 效率 Selenium 完备易读 非常活跃，问题通常能得到解答 Java,Python,PHP 基本支持所有主流浏览器 较为简单快捷，selenium加上相应浏览器与浏览器驱动即可 丰富且易于使用 较少 阻塞式，最慢，最好利用官方提供的selenium grid集群提升效率 Puppeteer 完备易读 相对活跃 Javascript,另外虽然有个人开发的pyppeteer作为python支持，但是不建议使用 本质其实是一个无头的chrome浏览器 基于node.js，需要使用npm安装，相对复杂 相对丰富但因为加入了协程机制使用起来较为复杂 目前仍然有不少坑 由于使用协程机制，速度较快 Splash 完备易读 相对活跃 Lua，对接scrapy时非常好用 本质是一个异步js渲染服务引擎 非常简单，使用docker安装 丰富，但使用起来时需要编写lua脚本作为请求参数，略微复杂 有一些但不多，可以接受 异步，配合协程机制（比如scrapy）很快 Howto be continued…]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2Fblog%2F2019%2F03%2F28%2FA-Test-Post%2F</url>
    <content type="text"><![CDATA[记录一下常用的markdown语法，just for convenience! 字体 语法 结果 *斜体* 斜体 **加粗** 加粗 ~~删除线~~ 删除线 字体下&lt;sub&gt;logo&lt;/sub&gt;标 字体下logo标 字体上&lt;sup&gt;logo&lt;/sup&gt;标 字体上logo标 &lt;u&gt;下划线&lt;/u&gt; 下划线 格式控制与转义字符 换行：使用连续两个回车或者&lt;br&gt;标签 缩进：使用转义字符中的空格 对齐：使用&lt;p align=”left/center/right”&gt;&lt;/p&gt;控制 转义：一般情况下使用\+需要转义的字符进行转义，部分字符需要使用下列转义字符表 转义字符 效果 解释 &amp;nbsp; &nbsp;缩进 不换行空格 &amp;ensp; &ensp;缩进 半角空格 &amp;emsp; &emsp;缩进 全角空格 &amp; &amp; 与号 &amp;lt; &lt; 小于符号 &amp;gt; &gt; 大于符号 标题1到6个#号表示从大到小6个级别的标题 分割线空行中三个以上的*号或者减号或者下划线为一个分割线，例如： 注释语法： &lt;!–注释–&gt; 效果： 注释不会被显示。 代码块行内代码语法： 这句`print(Hello world!)`是行内代码 效果： 这句print(Hello world!)是行内代码 代码框语法： ```bash ls -a ``` 效果：1ls -a 引用语法: > 引用1 > > 引用2 > > > 引用3 效果: 引用1 引用2 引用3 备注:引用作为一个区块，可以在区块内部嵌套使用列表、代码块、标题等，例如： 引用1（标题） 引用2（列表） 1引用3（代码块） 列表无序列表语法：+ list1 + list2 + list3 效果: list1 list2 list3 有序列表语法： 1. list1 2. list2 3. list3 效果: list1 list2 list3 备注:有序列表的序号是根据第一个列表项的序号自增的，比如第一个列表项的序号为3，那么不管之后的列表项的序号是多少，都会是4，5，6…… 表格语法： col1|col2|col3 :-|:-|:- dt|dt|dt dt|dt|dt dt|dt|dt 效果： col1 col2 col3 dt dt dt dt dt dt dt dt dt 备注：通过在第二行中调整冒号与横线实现表格对齐，具体如下： :- （左对齐） :-:（居中） -:（右对齐） 链接语法： [链接文字](链接地址) [链接文字](链接地址 “链接说明”) 效果： 链接文字 链接文字 图片语法： ![链接图片](链接地址) 效果：]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2019%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
